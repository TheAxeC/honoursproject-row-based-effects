\subsection{Big-Step Operational Semantics}
\todo{operational semantics}

\begin{figure}
\begin{center}
\framebox{
\begin{minipage}{0.95\columnwidth}
\[
  \text{result}~r \bnfis {}
    \ret v \bnfor
    \call{\op}{v}{\cont{y}{c}}
\]
\textbf{Evaluation}
\begin{mathpar}
  \inferrule[Eval-App]{
    c[v / x] \eval r
  }{
    (\fun{x} c) \, v \eval r
  }

  \inferrule[Eval-LetRec]{
    c_2[(\fun{x} \letrecin{f \, x = c_1} c_1) / f] \eval r
  }{
    \letrecin{f \, x = c_1} c_2 \eval r
  }

  \inferrule[Eval-Ret]{
  }{
    \ret v \eval \ret v
  }

  \inferrule[Eval-Op]{
  }{
    \op \, v \eval \call{\op}{v}{\cont{y}{\ret y}}
  }

  \inferrule[Eval-Do-Ret]{
    c_1 \eval \ret v \\
    c_2[v / x] \eval r
  }{
    \doin{x \leftarrow c_1} c_2 \eval r
  }

  \inferrule[Eval-Do-Op]{
    c_1 \eval \call{\op}{v}{\cont{y}{c_1'}}
  }{
    \doin{x \leftarrow c_1} c_2 \eval \call{\op}{v}{\cont{y}{\doin{x \leftarrow c_1'} c_2}}
  }

  \inferrule[Eval-With-Ret]{
    c \eval \ret v \\
    c_r[v / x] \eval r
  }{
    \withhandle{h}{c} \eval r
  }

  \inferrule[Eval-With-Handled-Op]{
    c \eval \call{\op}{v}{\cont{y}{c'}} \\
    c_\op[v / x, (\fun{y} \withhandle{h}{c'}) / k] \eval r
  }{
    \withhandle{h}{c} \eval r
  }

  \inferrule[Eval-With-Unhandled-Op]{
    c \eval \call{\op'}{v}{\cont{y}{c'}} \\
    \op' \not\in \ops
  }{
    \withhandle{h}{c} \eval \call{\op'}{v}{\cont{y}{\withhandle{h}{c'}}}
  }

%   \inferrule[Eval-If-True]{
%     c_1 \eval r
%   }{
%     \conditional{\tru}{c_1}{c_2} \eval r
%   }
%
%   \inferrule[Eval-If-False]{
%     c_2 \eval r
%   }{
%     \conditional{\fls}{c_1}{c_2} \eval r
%   }
\end{mathpar}
\end{minipage}
}
\end{center}
\caption{Operational semantics (in the last three rules, $h = \shorthand$)}\label{fig:semantics}
\end{figure}
%
% Figure~\ref{fig:semantics} defines the big-step operational
% semantics of \lang. The judgement $c \eval r$
% states that computation $c$ reduces to result $r$. A result is either a returned value,
% $\ret\,v$, or an unhandled operation, $\op\,v\,(y. c)$, where $v$ is the operation's
% parameter and $y.c$ is its continuation.
%
% The rules \textsc{Eval-App} and \textsc{Eval-LetRec} are straightforward.
% Next, the value result is generated by the $\ret\,v$ computation (\textsc{Eval-Ret}), while the unhandled
% operation (with trivial continuation $y.\ret\,y$) is generated by the $\op\,v$
% computation (\textsc{Eval-Op}). If the intermediate result of a sequential $\kord{do}$ is a value (\textsc{Eval-Do-Ret}),
% it is substituted into the second computation. If it is an unhandled operation (\textsc{Eval-Do-Op}),
% the second computation is appended to its continuation.  When a handled
% computation evaluates to a value (\textsc{Eval-With-Ret}), this value is substituted into the handler's
% return case. Finally, an unhandled operation is passed to
% the appropriate operation case, if there is one (\textsc{Eval-With-Handled-Op}), or propagated further, if there
% is not (\textsc{Eval-With-Unhandled-Op}). In either case, the continuation $y.c'$ is handled by the same handler.
