# Explanation of Eff source code

## Syntax
`syntax/typed.ml` represents the core/intermediate language used in the Eff compiler. The substitutions are also kept in this file. The smart constructors are defined below the substitutions. smart constructors are the typing rules as defined in the type system.

`syntax/sugared.ml` contains the source language of Eff.

`syntax/untyped.ml` converts the sugared language and distinguishes between values and terms. This is also a representation of the source language. No type inference has been done, as such, no types are available (untyped).

## Utils and Utils-old
### Utils
`const.ml` defines print, compare and constant definitions.

`error.ml` defines strings for error messages.

`location.ml` defines methods used to determine the location of code in the source file.

`poset.ml` defines a partially ordered set.

`print.ml` defines some common printing utilities.

`symbol.ml` contains methods that define how some symbols (such as handler arrow, subscripts, etc) need to be printed.

`trio.ml` defines methods related to type_params, dirt_params and region_params.

### Utils-old
`common.ml` defines some auxiliary functions mostly related to map manipulations.

`pattern.ml` contains some general pattern related methods.

`symbols.ml` contains methods that define how some symbols (such as handler arrow, subscripts, etc) need to be printed.

## Typing
`constraints.ml` contains the representation of constraints and unification.

`exhaust.ml` checks for exhaustiveness.

`infer.ml` implements the type inference algorithm. It does the conversion from untyped to typed.

`params.ml` defines the ty_param, dirt_param and region_param

`scheme.ml` defines the type schemes.

`smartPrint.ml` defines a smart (purity) printer.

`tctx.ml` defines type inference contexts.

`type.ml` defines some basic types.

`typingEnv.ml` defines a map (and functions) used for the environment.

## Runtime
`eval.ml` contains the main evaluation functions for the intermediate language.

`external.ml` defines functions that need to be defined externally, such as conversion, comparisons, etc.

`runtimeEnv.ml` defines a map (and functions) used for the environment in the runtime.

`value.ml` contains some definitions related to values.

## Parsing
`desugar.ml` desugars the syntax into the core language (from sugared to untyped).

`lexer.mll` defines how the source code is seperated into tokens.

`parser.mly` parses the tokens generated by the lexer into sugared syntax (from `syntax/sugared.ml`).

# Codegen
This folder contains the code that executes the term rewriting and the purity checks. This is contained in `codegen/optimize.ml`. `commonPrint.ml`, `purePrint.ml` and `simplePrint.ml` are just printers as their name states.

## Other files
`config.ml` contains the default values for the **optional parameters** that are available for the eff compiler.

`eff.ml` is the main file used for the binary (hence the name). It contains the **optional parameters** that can be used. The main function adds the pervasives, parses and lexer the file, infers the types, performs the optimizations and converts to OCaml code.

`shell.ml` is the main file used for the online editor. `exec_cmd` is the important function here. It takes a *parsed* source file, converts it to a typed language and evaluates it.

`version.ml` contains some version definitions. Currently these include the version and the directory of the eff binary.

## Special files
`pervasives.eff` is used in Eff files, while `header.ml` is used for the OCaml code generation.

`header.ml` contains definitions required for the code generation for the OCaml backend.

`pervasives.eff` contains header definitions for Eff including:
* operators
* range / map / ignore / fold / iter / ...
* math functions

## Recommended starting point
start with changing `syntax/typed.ml` so eff still compiles, afterwards change `typing/`.

`exec_cmd` in `shell.ml` also needs to be changed as it implements the toplevel.
